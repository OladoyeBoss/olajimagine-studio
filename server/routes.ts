import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { generateImageSchema, signupSchema, signinSchema } from "@shared/schema";
import { z } from "zod";
import bcrypt from "bcrypt";
import session from "express-session";

// Session configuration
declare module 'express-session' {
  export interface SessionData {
    userId: string;
  }
}

// Middleware to check authentication
function requireAuth(req: any, res: any, next: any) {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Authentication required" });
  }
  next();
}

// Email notification function using a simple email service
async function sendEmailNotification(submission: any) {
  // Using EmailJS or similar service for client-side email sending
  // For production, consider using SendGrid, Nodemailer with SMTP, or similar
  
  const emailData = {
    to_email: "oladoyejoel3@gmail.com", // Admin email
    from_name: submission.name,
    from_email: submission.email,
    message: submission.message,
    timestamp: submission.timestamp
  };
  
  // Simple webhook-based email notification
  // You can replace this with your preferred email service
  try {
    const response = await fetch("https://formspree.io/f/mrbgrvjv", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        email: submission.email,
        name: submission.name,
        message: `New contact form submission from ${submission.name} (${submission.email}):

${submission.message}

Submitted at: ${submission.timestamp}`,
      }),
    });
    
    if (!response.ok) {
      throw new Error(`Email service responded with status: ${response.status}`);
    }
    
    return true;
  } catch (error) {
    console.error("Failed to send email notification:", error);
    throw error;
  }
}

// API Configuration - Using GiftedTech with GET requests
const GIFTED_FLUX_API_URL = "https://api.giftedtech.web.id/api/ai/fluximg";
const GIFTED_SD_API_URL = "https://api.giftedtech.web.id/api/ai/sd";
const GIFTED_DEEP_API_URL = "https://api.giftedtech.web.id/api/ai/deepimg";
const GIFTED_API_KEY = "gifted";

// Image generation providers
interface ImageGenerationResult {
  imageUrl: string;
  provider: string;
}

async function generateWithFlux(prompt: string, size: string, quality: string): Promise<ImageGenerationResult> {
  const params = new URLSearchParams({
    apikey: GIFTED_API_KEY,
    prompt: prompt
  });

  const response = await fetch(`${GIFTED_FLUX_API_URL}?${params}`, {
    method: "GET",
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Flux API error: ${response.status} ${errorText}`);
  }

  const data = await response.json();
  const imageUrl = data.result || data.url || data.image_url || data.data?.url;
  
  if (!imageUrl) {
    throw new Error("No image URL returned from Flux API");
  }

  return { imageUrl, provider: "Flux" };
}

async function generateWithDemo(prompt: string, size: string, quality: string): Promise<ImageGenerationResult> {
  // Demo fallback with placeholder image
  const placeholderImages = [
    "https://picsum.photos/1024/1024?random=1",
    "https://picsum.photos/1024/1024?random=2", 
    "https://picsum.photos/1024/1024?random=3",
    "https://picsum.photos/1024/1024?random=4",
    "https://picsum.photos/1024/1024?random=5"
  ];
  
  const randomImage = placeholderImages[Math.floor(Math.random() * placeholderImages.length)];
  
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  return { 
    imageUrl: randomImage, 
    provider: "Demo Mode (Configure APIs in server/routes.ts)" 
  };
}

async function generateWithStableDiffusion(prompt: string, size: string, quality: string): Promise<ImageGenerationResult> {
  const params = new URLSearchParams({
    apikey: GIFTED_API_KEY,
    prompt: prompt
  });

  const response = await fetch(`${GIFTED_SD_API_URL}?${params}`, {
    method: "GET",
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Stable Diffusion API error: ${response.status} ${errorText}`);
  }

  const data = await response.json();
  const imageUrl = data.result || data.url || data.image_url || data.data?.url;
  
  if (!imageUrl) {
    throw new Error("No image generated by Stable Diffusion API");
  }

  return { imageUrl, provider: "Stable Diffusion" };
}

async function generateWithDeepSeek(prompt: string, size: string, quality: string): Promise<ImageGenerationResult> {
  const params = new URLSearchParams({
    apikey: GIFTED_API_KEY,
    prompt: prompt
  });

  const response = await fetch(`${GIFTED_DEEP_API_URL}?${params}`, {
    method: "GET",
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`DeepSeek API error: ${response.status} ${errorText}`);
  }

  const data = await response.json();
  const imageUrl = data.result || data.url || data.image_url || data.data?.url;
  
  if (!imageUrl) {
    throw new Error("No image URL returned from DeepSeek API");
  }

  return { imageUrl, provider: "DeepSeek" };
}

async function generateImageWithFallback(prompt: string, size: string, quality: string): Promise<ImageGenerationResult> {
  const providers = [
    { name: "Flux", fn: generateWithFlux },
    { name: "Stable Diffusion", fn: generateWithStableDiffusion },
    { name: "DeepSeek", fn: generateWithDeepSeek },
    { name: "Demo Mode", fn: generateWithDemo } // Always works as final fallback
  ];

  let lastError: Error | null = null;

  for (const provider of providers) {
    try {
      console.log(`Attempting image generation with ${provider.name}...`);
      const result = await provider.fn(prompt, size, quality);
      console.log(`Successfully generated image with ${provider.name}`);
      return result;
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      console.log(`${provider.name} failed:`, lastError.message);
      continue;
    }
  }

  throw new Error(`All image generation providers failed. Last error: ${lastError?.message}`);
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Configure session middleware
  app.use(session({
    secret: process.env.SESSION_SECRET || 'dev-secret-key-change-in-production',
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: false, // Set to true in production with HTTPS
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    },
  }));

  // Authentication routes
  app.post("/api/auth/signup", async (req, res) => {
    try {
      const validatedData = signupSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByUsernameOrEmail(validatedData.username);
      if (existingUser) {
        return res.status(400).json({ message: "Username already exists" });
      }

      const existingEmail = await storage.getUserByUsernameOrEmail(validatedData.email);
      if (existingEmail) {
        return res.status(400).json({ message: "Email already exists" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(validatedData.password, 10);

      // Check if user gets premium access
      const premiumEmails = [
        "oladoyejoel3@gmail.com",
        "faithjesus3@gmail.com", 
        "oladoyeheritage445@gmail.com"
      ];
      const isPremium = premiumEmails.includes(validatedData.email) ? "true" : "false";

      // Create user
      const user = await storage.createUser({
        username: validatedData.username,
        email: validatedData.email,
        password: hashedPassword,
        isPremium: isPremium,
      });

      res.status(201).json({ 
        message: "User created successfully", 
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email 
        }
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Invalid input", 
          errors: error.errors.map(e => e.message)
        });
      }
      
      console.error("Error creating user:", error);
      res.status(500).json({ message: "Failed to create user" });
    }
  });

  app.post("/api/auth/signin", async (req, res) => {
    try {
      const validatedData = signinSchema.parse(req.body);
      
      // Find user by username
      const user = await storage.getUserByUsername(validatedData.username);
      if (!user) {
        return res.status(401).json({ message: "Invalid username or password" });
      }

      // Verify password
      const isPasswordValid = await bcrypt.compare(validatedData.password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ message: "Invalid username or password" });
      }

      // Create session
      req.session.userId = user.id;

      res.json({ 
        message: "Sign in successful",
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email 
        }
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Invalid input", 
          errors: error.errors.map(e => e.message)
        });
      }
      
      console.error("Error signing in:", error);
      res.status(500).json({ message: "Failed to sign in" });
    }
  });

  app.post("/api/auth/signout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        console.error("Error destroying session:", err);
        return res.status(500).json({ message: "Failed to sign out" });
      }
      res.json({ message: "Signed out successfully" });
    });
  });

  app.get("/api/auth/me", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        req.session.destroy(() => {});
        return res.status(401).json({ message: "User not found" });
      }

      res.json({ 
        id: user.id, 
        username: user.username, 
        email: user.email 
      });
    } catch (error) {
      console.error("Error getting user:", error);
      res.status(500).json({ message: "Failed to get user" });
    }
  });
  // Generate image endpoint with fallback support (requires authentication)
  app.post("/api/generate-image", requireAuth, async (req, res) => {
    try {
      const validatedData = generateImageSchema.parse(req.body);
      
      // Generate image using fallback system
      const result = await generateImageWithFallback(
        validatedData.prompt,
        validatedData.size,
        validatedData.quality
      );

      // Store the generated image in our storage with user ID
      const savedImage = await storage.createGeneratedImage({
        userId: req.session.userId,
        prompt: validatedData.prompt,
        imageUrl: result.imageUrl,
        style: validatedData.style || "photorealistic",
        size: validatedData.size,
        quality: validatedData.quality,
        provider: result.provider,
      });

      res.json(savedImage);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input", errors: error.errors });
      }
      
      console.error("Error generating image:", error);
      res.status(500).json({ 
        message: error instanceof Error ? error.message : "Failed to generate image" 
      });
    }
  });

  // Get generated images for authenticated user
  app.get("/api/images", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 20;
      const offset = parseInt(req.query.offset as string) || 0;
      
      const images = await storage.getUserGeneratedImages(req.session.userId, limit, offset);
      res.json(images);
    } catch (error) {
      console.error("Error fetching images:", error);
      res.status(500).json({ message: "Failed to fetch images" });
    }
  });

  // Get single image
  app.get("/api/images/:id", async (req, res) => {
    try {
      const image = await storage.getGeneratedImage(req.params.id);
      if (!image) {
        return res.status(404).json({ message: "Image not found" });
      }
      res.json(image);
    } catch (error) {
      console.error("Error fetching image:", error);
      res.status(500).json({ message: "Failed to fetch image" });
    }
  });

  // Delete image endpoint (requires authentication and ownership)
  app.delete("/api/images/:id", requireAuth, async (req, res) => {
    try {
      const image = await storage.getGeneratedImage(req.params.id);
      if (!image) {
        return res.status(404).json({ message: "Image not found" });
      }

      // Check if the image belongs to the authenticated user
      if (image.userId !== req.session.userId) {
        return res.status(403).json({ message: "You can only delete your own images" });
      }

      await storage.deleteGeneratedImage(req.params.id);
      res.json({ message: "Image deleted successfully" });
    } catch (error) {
      console.error("Error deleting image:", error);
      res.status(500).json({ message: "Failed to delete image" });
    }
  });

  // Contact form endpoint
  app.post("/api/contact", async (req, res) => {
    try {
      const { name, email, message } = req.body;
      
      const contactSubmission = {
        name,
        email,
        message,
        timestamp: new Date().toISOString()
      };
      
      console.log("ðŸ“§ New Contact Form Submission:", contactSubmission);
      
      // Store contact submission in database for admin review
      await storage.createContactSubmission({
        name,
        email,
        message,
        timestamp: contactSubmission.timestamp
      });
      
      // Send email notification to admin
      try {
        await sendEmailNotification(contactSubmission);
        console.log("âœ… Email notification sent successfully");
      } catch (emailError) {
        console.log("âš ï¸ Failed to send email notification:", emailError);
        // Don't fail the request if notification fails
      }
      
      res.json({ 
        message: "Thank you for your message! We'll get back to you soon.",
        submissionId: Date.now().toString()
      });
    } catch (error) {
      console.error("âŒ Error processing contact form:", error);
      res.status(500).json({ message: "Failed to send message. Please try again." });
    }
  });

  // Update profile endpoint (requires authentication)
  app.post("/api/auth/update-profile", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const { username, currentPassword, newPassword } = req.body;
      
      // Verify current password if provided
      if (currentPassword) {
        const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
        if (!isPasswordValid) {
          return res.status(401).json({ message: "Current password is incorrect" });
        }
      }

      const updates: any = {};
      
      // Update username if provided
      if (username && username !== user.username) {
        // Check if username is already taken
        const existingUser = await storage.getUserByUsername(username);
        if (existingUser && existingUser.id !== user.id) {
          return res.status(400).json({ message: "Username already exists" });
        }
        updates.username = username;
      }

      // Update password if provided
      if (newPassword && currentPassword) {
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        updates.password = hashedPassword;
      }

      // Handle profile picture upload (simplified - in production use proper file upload middleware)
      // For now, we'll just store a placeholder URL
      const profilePictureFile = req.body.profilePicture;
      if (profilePictureFile) {
        // In a real app, you'd upload to cloud storage and get a URL
        updates.profilePicture = `https://ui-avatars.com/api/?name=${encodeURIComponent(username || user.username)}&background=6366f1&color=fff&size=200`;
      }

      // Update user profile
      await storage.updateUser(user.id, updates);

      res.json({ 
        message: "Profile updated successfully",
        user: {
          id: user.id,
          username: updates.username || user.username,
          email: user.email,
          profilePicture: updates.profilePicture || user.profilePicture
        }
      });
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Get contact submissions for admin (requires authentication)
  app.get("/api/contact/submissions", requireAuth, async (req, res) => {
    try {
      // Only allow specific admin users to view submissions
      const user = await storage.getUser(req.session.userId);
      const adminEmails = [
        "oladoyejoel3@gmail.com",
        "faithjesus3@gmail.com", 
        "oladoyeheritage445@gmail.com"
      ];
      
      if (!user || !adminEmails.includes(user.email)) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const submissions = await storage.getContactSubmissions();
      res.json(submissions);
    } catch (error) {
      console.error("Error fetching contact submissions:", error);
      res.status(500).json({ message: "Failed to fetch submissions" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
